# 错误处理文档

邓新宇 18231045

## 整体思路

当发现了不符合文法的token之后, 分为两种处理方式:
1. 直接跳过即将分析的语法成分, 直接继续分析后面的成分;
2. 不断向后寻找，直至找到符合当前语法成分的token, 或者找到符合下一语法成分的token. 若是后一种情况, 仍旧需要跳过即将分析的语法成分;

根据题目要求, 对于分号`;`、右圆括号`)`、右方括号`]`这类需要在当前行报错的问题, 宜采用第一种处理方式, 这种错误往往是漏写造成的, 而其它错误则通过第二种处理方式来处理.



## 具体实现

第一种处理方式可以简单地为原先的`dequeue()`方法添加替代方法`dequeue(SymbolType type)`, 添加可以传入一个期望类型的参数, 如果符合期望就将其弹出, 否则不做任何处理.

由于语法成分的分支判断不是简单的预读一个token就可以完成, 在语法分析部分已经将其封装为`in_branch_of<>()`函数, 所以不能简单仿照课程组提供的pascal-s编译器那样
> 传入两个集合和一个错误码, 当符合第一个集合时, 成功; 不符合第一个集合时, 按照错误码进行报错, 将两个集合求并集, 一直往后寻找该并集内的token.

需要将两个集合的判断转换为两个函数的判断, 利用标准库`<functional>`中的设施便可以完成, 为了方便使用, 提供一些重载和工具类, 将`initializer_list<SymbolType>`转换为判断预读token是否落在该集合内的方法, 大大简化了主要逻辑部分的代码.

此外, 还有许多课程没有要求的错误, 依旧需要进行处理, 并设置错误码`z`将其进行标记, 以增强编译器的健壮性.

