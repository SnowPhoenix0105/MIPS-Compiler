# 分析文档

邓新宇 18231045

## 整体思路

首先, 分析给定文法, 显然给定文法不是一个`LL(1)`文法, 由于题目规定了各个非终结符的输出动作, 所以不方便进行语法改写, 直接按照给定文法进行递归下降.

虽然给定文法不是`LL(1)`文法, 但大部分分支决策, 仅预读1个token就足够了, 所以在进行分支决策时, 默认仅进行`FIRST`集的检查, 需要额外预读的再进行预读.

由于需要进行多个预读, 所以就需要一个顺序容器来保存token序列.

记`peek(i)`为向前查看`i`个token, 则有如下子程序需要额外判断(不包括`FIRST`集的判断):

|需要额外判读子程序|判断内容|
|:-|:-|
|变量声明|peek(2) != `LPAREN`|
|变量定义|peek(2) != `LPAREN`|
|有返回值的函数定义|peek(2) == `LPAREN`|
|无返回值函数定义|peek(1) != `MAINTK`|
|主函数|peek(1) == `MAINTK`|
|变量定义及初始化|peek(2) == `ASSIGN` *or* peek(2) == `LBRACK` and peek(5) == `ASSIGN` *or* peek(2) == `LBRACK` and peek(5) == `LBRACK` and peek(8) == `ASSIGN`|
|变量定义无初始化|peek(2) != `ASSIGN`*and* (peek(2) != `LBRACK` or peek(5) != `ASSIGN`) *and* peek(2) != `LBRACK` or peek(5) != `LBRACK` or peek(8) != `ASSIGN`|
|有返回值函数调用语句|peek(0)对应的标识符在符号表中为有返回值函数|
|无返回值函数调用语句|peek(0)对应的标识符在符号表中为无返回值函数|
|赋值语句|peek(0)对应的标识符在符号表中为变量/一维数组/二维数组|



## 具体实现

在设计递归下降的程序时, 采用如下策略进行解耦:

1. 每一个要求输出的非终结符对应一个子程序 (不要求输出的非终结符都是词法分析的目标, 可以说对于语法分析, 不要求输出的都是终结符);
2. 每个子程序封装为一个子程序类, 该类重载了调用运算符, 将各个子程序间共享的信息, 如当前符号表、token序列等封装为一个类, 记为env, 每次递归下降时将env传递给子程序, env提供了一些封装方法, 如`peek(n)`向前查看n个token, `dequeue()`取走一个token, 等等;
3. 子程序类有一个静态的获取`FIRST`集的方法`fist_set()`, 标明了该类的`FIRST`集;
4. 对于需要多次预读才可以判断的情况, 往往引发这种情况的原因是多个类的`FIRST`集有交集, 所以这种情况不适合将判断逻辑分散到各个子程序类中, 故通过模板及特例化实现这种方式, 即为所有子程序的基类添加模板方法`in_branch_of<Subroutine>(env)`, 默认实现为检查env中下一个字符是否在子程序Subroutine的`FIRST`集中, 对于需要额外判断的Subroutine, 为其编写该模板的特例化来进行额外的检查;
5. 每一个子程序的前置条件为env符合`in_branch_of`的检查;

一方面为了区分`有返回值函数调用语句`和`无返回值调用语句`, 另一方面为了方便后续语义分析, 在env中加入了符号表管理.


## 编码细节

由于递归子程序需要很大的代码量, 所以需要一些规范来减少出错.

1. 在子程序右侧对齐进行标注: 每当调用`env.dequeue()`时, 标注期望出列的token时什么类型的; 每当调用子程序时, 标注子程序的名称. 这样通过查看右边对其的注释, 就可以轻松查看该非终结符的判断是否编写完全;
2. 头文件中每一个子程序类的类名前、源文件中每一个分析函数前都标明该非终结符的中文名, 方便查找和debug;
3. 为了方便后续错误处理, 每次调用`env.dequeue()`前要检查`env.peek()`(此dequeue是本非终结符的第一个终结符时除外, 因为每一个子程序的前置条件已经保证其正确性了), 每次调用子程序前检查`in_branch_of`, 检查不通过时标注`// TODO error`, 方便后续错误处理时定位错误位置.

