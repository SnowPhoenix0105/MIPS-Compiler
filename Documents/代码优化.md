

# 三 代码优化

## 3.1 寄存器分配

寄存器分配是花费时间最多的一项优化. 

### 3.1.1 图着色法全集寄存器分配

通过基本块划分和全局活跃变量分析, 可以得知哪些变量需要跨越基本块, 利用前文提到的数据结构`Graph<>`, 为其通过图着色法分配全局寄存器`$sx`, 注意函数的参数往往是全局变量, 但是部分参数已经分配了`$ax`寄存器, 分配寄存器时可以不考虑这些变量, 但是最后记录分配结果的时候可以加到结果之中.

### 3.1.2 寄存器池进行局部寄存器分配与栈上保护

通过寄存器池的方法分配临时寄存器. 我采用的是`GC` + `dirty`策略.

* 当需要临时寄存器时, 如果有空闲的临时寄存器, 将其分配给这个变量;
* 当需要临时寄存器时, 如果没有空闲的临时寄存器, 触发垃圾回收, 首先将回收已经失活的变量的临时寄存器, 这可以通过局部活跃变量分析获得, 若此时有了空闲的临时寄存器, 则退出`GC`; 否则, 检查函数内的全局变量和`gvar`标记的函数外全局变量, 如果它们不是`dirty`的, 那么将其释放; 同理, 下一步将释放一个`dirty`的全局变量或`gvar`, 然后尝试释放一个正在活跃的局部变量.
* 当一个临时寄存器被写入时, 将其标记为`dirty`;

`dirty`维护的是该变量是否和栈上的值一致(如果有的话). 当退出当前基本块或者发生函数调用时, 所有`$tx`寄存器中的值都要保存到栈上, 此时通过`dirty`标记, 将与栈上内容不一致的变量通过二级中间代码的`protect`指令保存到栈上. 需要使用内容在栈上的变量时, 使用`reload`指令将其加载至寄存器.

### 3.1.3 $ax寄存器分配与函数调用

对于寄存器分配, 最困难的是函数调用时`$ax`的处理:

函数传参, 使用`$a0`-`$a3`, 函数返回值仅使用`$v1`. 而`$v0`作为syscall和sw的保留寄存器.

发生函数压参时, 先统计到`call`之前, 有多少`push`指令, 然后将所有活跃的`$ax`寄存器压入本函数块的栈中, 然后将所有对本函数的参数的引用改为同全局变量相同的方式, 即先加载到临时寄存器后使用. 若`push`多于4个, 则将多余的参数压栈至下一函数块.


发生函数压参时, 先统计到`call`之前, 有多少`push`指令, 并记录`call`指令下标.
倒数4个`push`指令之前只需做简单的`var2reg`.
倒数的4个`push`指令, 先考察当先指令结束后`$ax`是否仍旧活跃, 
* 若不活跃, 则无需保存, 但注意如果在此之后, `call`之前如果`$ax`恢复活跃, 则需要分配至`$tx`.
* 若此`push`后仍旧活跃, 再考察在该`push`至`call`之间考查`$ax`中保存的变量是否使用到, 
  * 若使用到, 则将其移动至`$tx`中(并且直到`call`之前, `$tx`不能被置换到栈中), 发生`call`时直接由`$tx`保存至栈中指定位置;
  * 若未使用到, 且在`call`之后, 仍旧活跃, 则将其保护至栈中. 
`call`结束后, 若`$ax`仍旧活跃, 则从栈中重新加载.


## 3.2 修复前端中间代码生成的缺陷

由于前端中间代码设计失误, 导致出现一些缺陷:

对于表达式, 项, 因子等非终结符的语法制导分析, 对于保存其结果的变量, 本来应该是一个继承属性, 这样`a=b+c`这样的属性就可以顺利地生成`a=b+c`这样的一条中间指令, 但是前端设计时, 将其作为了综合属性, 此时`a=b+c`将被生成`t0=b+c; a=t0+0`这样多条指令, 即多出了无用的拷贝, 所以需要通过探查无用的近处拷贝来消除这样的冗余.

对于每一个形如`a=b+c`, `a=b-c`, `scanf a`的指令, 将检查其下一条指令, 如果下一条指令是一个形如`x=a+0`的简单拷贝语句(将`a`拷贝至其它变量), 并且下一条指令的活跃变量分析中`out`集不包含`a`, 那么就删除这两条指令, 改为`x=b+c`, `x=b-c`, `scanf x`. 并且这个过程可以一直迭代下去, 直至不满足条件.


## 3.3 常量合并

对于形如`a=1+2`, `a = 9 / 3`这类指令, 可以将其转换为`a=0+3`, 再配合常量传播, 可以进行一些编译器计算.

事实上, 数组名`<arr>`可以被视为一个常量, 但是其值必须要在完成栈空间分配后才能确定, 所以要通过特殊的数据结构保存数组名`<arr>`与立即数`<imm>`合并后的结果. 正确情况下只会`<arr> + <imm>`这种形式, 所以只需要保存这种形式即可.


## 3.4 运算强度削弱

如果`<imm>`是2的整数次幂, 那么可以将`<var>/<imm>`和`<var>*<imm>`转换为位移操作.

但是直接进行位移并不一定是正确的:

```	
            sr  div
-20	>>	3	-3	-2
-19	>>	3	-3	-2
-18	>>	3	-3	-2
-17	>>	3	-3	-2
-16	>>	3	-2	-2
-15	>>	3	-2	-1
-14	>>	3	-2	-1
-13	>>	3	-2	-1
-12	>>	3	-2	-1
-11	>>	3	-2	-1
-10	>>	3	-2	-1
-9	>>	3	-2	-1
-8	>>	3	-1	-1
-7	>>	3	-1	0
-6	>>	3	-1	0
-5	>>	3	-1	0
-4	>>	3	-1	0
-3	>>	3	-1	0
-2	>>	3	-1	0
-1	>>	3	-1	0
0	>>	3	0	0
1	>>	3	0	0
2	>>	3	0	0
3	>>	3	0	0
4	>>	3	0	0
5	>>	3	0	0
6	>>	3	0	0
7	>>	3	0	0
8	>>	3	1	1
9	>>	3	1	1
10	>>	3	1	1
11	>>	3	1	1
12	>>	3	1	1
13	>>	3	1	1
14	>>	3	1	1
15	>>	3	1	1
16	>>	3	2	2
17	>>	3	2	2
18	>>	3	2	2
19	>>	3	2	2
```
对于负数情况, 除法运算将结果向绝对值小的方向舍位为整数, 但是右移运算向值小的方向舍位.

观察成熟的编译器mips-gcc编译的结果, 这段代码是将`$2`中的数除以16后保存至`$2`:

```asm
addiu	$3,$2,15
slt		$4,$2,0
movn	$2,$3,$4
sra		$2,$2,4
```

可见, 对于被除数为负数的情况, 先将其增加$2^N-1$然后再进行位移运算, 就可以得到正确结果.

从这里也可以观察到`movn`指令的使用, 这也启发我进行了此体系结构相关的优化.

对于乘法, 实验结果显示无论正负, 位移的结果和乘法的结果一致.

## 3.5 movn & movz优化

对于如下形式的代码, 可以进行此体系结构相关优化:

```asm
bne <cmp1>, <zero>, L1
	mov  <var1>, <val1>
L1:


bne <cmp2>, <zero>, L2
	mov  <var1>, <val2>
	goto L3
L2:
	mov <var1>, <val3>
L3:
```
可以分别优化为
```
movz <var1>, <val1> <cmp1>


addu <var1>, <val2> <zero>
movn <var1>, <val3> <cmp1>
```
大大缩减了jump开销.

## 3.6 局部公共子表达式删除

目前暂未实现, 但是已经有其所需的数据结构有权图`Graph<>`.

需要注意的有两方面, 一个是数组, 当对一个数组的某个变量赋值后, 应当认为所有从该数组获得值的变量失效, 不应当再被后续视作公共子表达式, 另一个是全局变量, 当进行函数调用后, 应当认为全局变量全部被更改过, 也不应当作为公共子表达式的载体.


## 3.7 循环展开

在先行评价体系下, 对生成的目标代码长度没有要求, 所以循环展开后一定是能够提高效率的, 只要不超出MARS的text段长度即可.