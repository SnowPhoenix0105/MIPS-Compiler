
## 中间代码约定

1. 每一个普通变量名、临时变量名都对应一个伪寄存器, 可以直接进行运算操作, 不需要加载、保存;
2. 每一个数组名实际上都是一个偏移地址常量, 但这个常量的值需要在结束优化后, 目标代码生成时才可以确定;




## 标识符约定

### 局部普通变量命名:
```
<函数名>$ver$<变量名>
```

### 局部数组变量命名：
```
<函数名>$arr$<类型>$<总长度>$<数组名>
```

### 临时变量命名
```
<函数名>$tmp$<编号>
```

### 全局变量命名
```
__global$var$<变量名>
```

### 全局数组变量命名：
```
__global$arr$<类型>$<总长度>$<数组名>
```

### 函数标签
```
__func$beg$<函数名>
__func$end$<函数名>


                            othercodes
__func$beg$<>:  <- - - - call __func$beg$<>
    content       + - -> follow-codes
    ret   - - - - +
__func$end$<>: 
```

### 循环相关标签

for
```
__for$beg$<编号>
__for$end$<编号>


initialization
__for$beg$<>:          false
  ↑   condition-judge - - - +
  |   content               | 
  |   iter-move-on          |
  + - goto                  |  
__for$end$<>:   < - - - - - +
```
while
```
__while$beg$<编号>
__while$end$<编号>


__while$beg$<>:        false
  ↑   condition-judge - - - +
  |   content               | 
  + - goto                  |  
__while$end$<>: < - - - - - +
```

### 分支相关标签
```
__if$brg$<编号>
__else$beg$<编号>
__else$end$<编号>

        _if$beg$<>:        false
        condition-judge - - - - - +
            success-content       |
 + - - - - -goto                  |
 |      __else$beg$<>: <- - - - - +
 |          false-content
 + - -> __else$end$<>:
```




## 中间代码约定

### 数值运算

`<source1>`和`<source2>`可以为以下形式:

| 描述           | 形式               |
| :------------- | :----------------- |
| 立即数         | \<number\>         |
| 变量名         | \<id\>             |


#### 加法

```
<dst> = <source1> + <source2>

add <dst> <source1> <source2>
```

#### 减法
```
<dst> = <source1> - <source2>

sub <dst> <source1> <source2>
```

#### 乘法
```
<dst> = <source1> * <source2>

mult <dst> <source1> <source2>
```

#### 整数除法
```
<dst> = <source1> / <source2>

div <dst> <source1> <source2>
```

#### 小于
```
<dst> = <source1> < <source2>

less <dst> <source1> <source2>
```

#### 小于等于
```
<dst> = <source1> <= <source2>

leq <dst> <source1> <source2>
```

#### 大于
```
<dst> = <source1> > <source2>

great <dst> <source1> <source2>
```

#### 大于等于
```
<dst> = <source1> >= <source2>

geq <dst> <source1> <source2>
```

#### 等于
```
<dst> = <source1> == <source2>

equal <dst> <source1> <source2>
```

#### 不等于
```
<dst> = <source1> != <source2>

neq <dst> <source1> <source2>
```

---
### 数组运算


```
<source> <offset> <dst> 都是变量名
<arr> 是数组名

sw <source> <arr> <offset>
sb <source> <arr> <offset>
lw <dst> <arr> <offset>
lb <dst> <arr> <offset>
```

---

### 分支

#### 等于转移

```
if <var1> == <var2> goto <label>

beq <var1> <var2> <label>
```

#### 不等于转移

```
if <var1> != <var2> goto <label>

bne <var1> <var2> <label>
```

#### 无条件跳转
```
goto  <label>
```



---

### 函数调用

#### 函数压参
```
         0     1           <ord>
<func> (..., ..., ......, <value>, ...);

param <func> <ord> <value>
```

#### 函数调用(应当先param压参)
```
<func>()

call <func>
```

#### 函数返回
```
// 有返回值
return(<value>)

ret 1 <value>

// 无返回值
return

ret 0
```


## 寄存器使用约定

| 编号  | 别名  | 用途         |
| :---- | :---- | :----------- |
| 0     | zero  | 常量0        |
| 1     | at    | 汇编器保留   |
| 2     | v0    | 函数返回值   |
| 3     | v1    | 计算数组下标 |
| 4-7   | a0-a3 | 函数参数0-3  |
| 8-15  | t0-t7 | 临时0-7      |
| 16-23 | s0-s7 | 保存0-7      |
| 24-25 | t8-t9 | 临时8-8      |
| 26-27 | k0-k2 | 内核保留0-1  |
| 28    | gp    | 全局指针     |
| 29    | sp    | 栈顶指针     |
| 30    | fp    | 栈帧指针     |
| 31    | ra    | 返回地址     |

## 运行栈结构

由于返回值大小都小于1字, 故不需要再在栈上分配返回值.

```
  +-----------------------+ <-- $sp 0
  |   caller-saved-regs   |
  +-----------------------+
  |      params    n      |
  |                0      |
  +-----------------------+ <-- $fp
  |   callee-saved-regs   |
  +-----------------------+
  |       variables       |
  +-----------------------+ <-- $sp
```
函数调用顺序:

0. 编译器计算调用方压栈空间和函数参数占用空间, 得到`<dr>`, 编译器计算被调用方保存寄存器和变量占用空间, 的得到`<de>`,
1. 调用方从`$sp`向下将需要保存的寄存器压栈, 再向下将实参压栈