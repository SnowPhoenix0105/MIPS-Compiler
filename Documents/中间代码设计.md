
## 中间代码约定

1. 每一个普通变量名、临时变量名都对应一个伪寄存器, 可以直接进行运算操作, 不需要加载、保存;
2. 每一个数组名实际上都是一个偏移地址常量, 但这个常量的值需要在结束优化后, 目标代码生成时才可以确定;




## 标识符约定

### 栈顶
`$sp`是一个不应当被赋值的变量, `$sp`的变化由最后生成汇编时进行
```
$sp
```
数组的数据位置为:
```
$sp + <arr> + <offset>
```
### 返回值
使用ret语句前, 如果当前函数有返回值, 需要对其进行赋值.
```
$ret
```

### 局部普通变量命名:
```
<函数名>$ver$<变量名>
```

### 局部数组变量命名：
```
<函数名>$arr$<类型>$<总长度>$<数组名>
```

### 临时变量命名
```
<函数名>$tmp$<编号>
```

### 全局变量命名
```
__global$var$<变量名>
```

### 全局数组变量命名：
```
__global$arr$<类型>$<总长度>$<数组名>
```

### 函数标签
```
func_beg_<函数名>
func_mid_<函数名>
func_end_<函数名>

                         othercodes
      func_beg: <- - - - call func_beg
          content   + -> follow-codes        
+ - - -   ret       |
|         content   |
+ ->  func_mid:     |
          jr  - - - +
      func_end: 
```

### 循环相关标签

for
```
for_beg_<编号>
for_mid_<编号>
for_end_<编号>


          initialization
+ - - -   goto
|     for_beg:   <- - - - - - +
|         content             | success 
|         iter-move-on        |
+ ->  for_mid:                |
          condition-judge - - +
      for_end:  
```
while
```
while_beg_<编号>
while_mid_<编号>
while_end_<编号>


+ - - -   goto
|     while_beg:   <- - - - - +
|         content             | success 
+ ->  while_mid:              |
          condition-judge - - +    
      while_end: 
```

### 分支相关标签
```
if_beg_<编号>
if_mid_<编号>
if_end_<编号>

                          false
          condition-judge - - - +
      if_beg:                   |
          success-content       |
 + - - - - -goto                |
 |    if_mid:    <- - - - - - - +
 |        false-content
 + -> if_end:
```




## 中间代码约定

### 数值运算

`<source1>`和`<source2>`可以为以下形式:

| 描述           | 形式               |
| :------------- | :----------------- |
| 立即数         | \<number\>         |
| 变量名         | \<id\>             |


#### 加法

```
<dst> = <source1> + <source2>

add <dst> <source1> <source2>
```

#### 减法
```
<dst> = <source1> - <source2>

sub <dst> <source1> <source2>
```

#### 乘法
```
<dst> = <source1> * <source2>

mult <dst> <source1> <source2>
```

#### 整数除法
```
<dst> = <source1> / <source2>

div <dst> <source1> <source2>
```

#### 小于
```
<dst> = <source1> < <source2>

less <dst> <source1> <source2>
```

#### 小于等于
```
<dst> = <source1> <= <source2>

leq <dst> <source1> <source2>
```

#### 大于
```
<dst> = <source1> > <source2>

great <dst> <source1> <source2>
```

#### 大于等于
```
<dst> = <source1> >= <source2>

geq <dst> <source1> <source2>
```

#### 等于
```
<dst> = <source1> == <source2>

equal <dst> <source1> <source2>
```

#### 不等于
```
<dst> = <source1> != <source2>

neq <dst> <source1> <source2>
```

---
### 数组运算


```
<source> <offset> <dst> 都是变量名
<arr> 是数组名

sw <source> <arr> <offset>
sb <source> <arr> <offset>
lw <dst> <arr> <offset>
lb <dst> <arr> <offset>
```

---

### 分支

#### 等于转移

```
if <var1> == <var2> goto <label>

beq <var1> <var2> <label>
```

#### 不等于转移

```
if <var1> != <var2> goto <label>

bne <var1> <var2> <label>
```

#### 无条件跳转
```
goto  <label>
```



---

### 函数调用

#### 函数压参
```
<func> (..., ..., ......, <value>, ...);

param <value>
```

#### 函数调用(应当先param压参)
```
<func>()

call <func>
```

#### 函数返回
```
// 有返回值
return(<value>)

ret <value>

// 无返回值
return

ret <null>
```


## 寄存器使用约定

| 编号  | 别名  | 用途         |
| :---- | :---- | :----------- |
| 0     | zero  | 常量0        |
| 1     | at    | 汇编器保留   |
| 2     | v0    | 函数返回值   |
| 3     | v1    | 计算数组下标 |
| 4-7   | a0-a3 | 函数参数0-3  |
| 8-15  | t0-t7 | 临时0-7      |
| 16-23 | s0-s7 | 保存0-7      |
| 24-25 | t8-t9 | 临时8-8      |
| 26-27 | k0-k2 | 内核保留0-1  |
| 28    | gp    | 全局指针     |
| 29    | sp    | 栈顶指针     |
| 30    | fp    | 栈帧指针     |
| 31    | ra    | 返回地址     |

## 运行栈结构

由于返回值大小都小于1字, 故不需要再在栈上分配返回值.
